#version 450
#extension GL_EXT_debug_printf : enable
#extension GL_ARB_shading_language_include : require

#include "../shader_includes/ray.glsl"
#include "../shader_includes/dda.glsl"
#include "../shader_includes/debug.glsl"

#define NODE_SIZE 4
#define MAX_RAY_STEPS 100
#define EPSILON 0.0001
#define TO_1D(pos, size) ((pos.z * size * size) + (pos.y * size) + pos.x)

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(binding = 0, rgba8) uniform writeonly image2D img;

/*
pub struct RenderBuffer {
    pub pos: Vec3,
    pub screen_size_x: f32,
    pub dir: Vec3,
    pub screen_size_y: f32,
}
*/
layout(binding = 1) uniform UniformBufferObject {
    vec4 pos; // w is screen_size_x
    vec4 dir; // w is screen_size_y
    uint num_chunks;
} render_buffer;

#define POS render_buffer.pos.xyz
#define DIR render_buffer.dir.xyz
#define RES_X render_buffer.pos.w
#define RES_Y render_buffer.dir.w
#define RES vec2(RES_X, RES_Y)
#define NUM_CHUNKS render_buffer.num_chunks

struct ChunkData {
    mat4 transform;
    vec4 aabb_min; // w ist chunk size as u32
    vec4 aabb_max;
};

#define CHUNK_TRANSFORM(chunk_data) chunk_data.transform
#define AABB_MIN(chunk_data) chunk_data.aabb_min.xyz
#define AABB_MAX(chunk_data) chunk_data.aabb_max.xyz
#define CHUNK_SIZE(chunk_data) floatBitsToUint(chunk_data.aabb_min.w)

layout(binding = 2) buffer ChunkDatas {
    ChunkData chunks[];
} chunk_datas;

layout(binding = 3) buffer ChunkNodes {
    uint node_ids[];
} chunk_nodes;

#define GET_NODE_ID(pos, chunk_size, offset) chunk_nodes.node_ids[TO_1D(pos, chunk_size) + offset]
struct Rot {
    mat4 mat;
    ivec3 offset;
};
Rot GET_ROT_FROM_NODE_ID(uint nodeID) {
    uint index_nz1 = nodeID & 3;
    uint index_nz2 = (nodeID >> 2) & 3;
    uint index_nz3 = 3 - index_nz1 - index_nz2;

    int row_1_sign = (nodeID & (1 << 4)) == 0 ? 1 : -1;
    int row_2_sign = (nodeID & (1 << 5)) == 0 ? 1 : -1;
    int row_3_sign = (nodeID & (1 << 6)) == 0 ? 1 : -1;

    mat4 mat = mat4(0);
    mat[index_nz1][0] = row_1_sign;
    mat[index_nz2][1] = row_2_sign;
    mat[index_nz3][2] = row_3_sign;
    mat[3][3] = 1;

    Rot rot = Rot(mat, ivec3(row_1_sign == -1, row_2_sign == -1, row_3_sign == -1));
    return rot;
}
#define GET_NODE_INDEX_FROM_NODE_ID(nodeID) nodeID >> 7

// Voxels
struct Node {
    uint voxels[(NODE_SIZE * NODE_SIZE * NODE_SIZE) / 4];
};

layout(binding = 4) uniform Nodes {
    Node nodes[];
} nodes;

// Materials 
layout(binding = 5) uniform Mats {
    uint mats[];
} mats;

int next_chunk(in Ray ray, out float t) {
    float best_t = 1000000;
    int best_index = -1;
    for (int i = 0; i < NUM_CHUNKS; i++) {

        ChunkData chunk_data = chunk_datas.chunks[i];

        float t_max;
        if (aabb_ray_test(ray, AABB_MIN(chunk_data), AABB_MAX(chunk_data), t, t_max) && t > 0 && t < best_t) {
            best_t = t;
            best_index = i;
        }
    }

    t = best_t;
    return best_index;
}

bool ray_trace(in Ray ray, in float t, in uint chunk_index, out uint step_count) {
    ChunkData chunk_data = chunk_datas.chunks[chunk_index];
    uint chunk_size = CHUNK_SIZE(chunk_data);
    uint chunk_node_id_offset = 0;

    vec3 chunk_pos = (chunk_data.transform * vec4(0, 0, 0, 1)).xyz;
    vec3 global_ray_enter = ray.origen + ray.dir * (t + EPSILON);

    // DDA init
    vec3 local_pos = global_ray_enter - chunk_pos;
    DDA dda = init_DDA(ray, local_pos, ivec3(chunk_size));

    /*
    if (gl_GlobalInvocationID.xy == vec2(640, 360)) {
        debugPrintfEXT("Pos: %f %f %f", local_pos);
    }
    */

    step_count = 0;
    while (step_count < MAX_RAY_STEPS) {
        uint node_id = GET_NODE_ID(dda.cell, chunk_size, chunk_node_id_offset);
        uint node_index = GET_NODE_INDEX_FROM_NODE_ID(node_id);
        if (node_index > 0) {
            return true;
        }

        if (gl_GlobalInvocationID.xy == vec2(640, 360)) {
            debugPrintfEXT("Cell: %d %d %d", dda.cell.x, dda.cell.y, dda.cell.z);
        }

        dda = step_DDA(dda);
        if (dda.out_of_bounds) {
            break;
        }

        step_count++;
    }

    return false;
}

void main () {
    Ray ray = init_ray(POS, DIR, RES);

    float t;
    int next_chunk = next_chunk(ray, t);

    vec3 color = ray.dir;
    if (next_chunk != -1) {
        color *= 0.7;

        uint step_count;
        if (ray_trace(ray, t, next_chunk, step_count)) {

        }

        color = step_count_color(step_count, MAX_RAY_STEPS);
    }

    imageStore(img, ivec2(gl_GlobalInvocationID.xy), vec4(color, 0));
}

