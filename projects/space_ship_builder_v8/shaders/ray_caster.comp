#version 450
#extension GL_EXT_debug_printf : enable

#define NODE_SIZE 4
#define USE_BRANCHLESS_DDA true
#define MAX_RAY_STEPS 100
#define EPSILON 0.0001

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(binding = 0, rgba8) uniform writeonly image2D img;

/*
pub struct RenderBuffer {
    pub pos: Vec3,
    pub screen_size_x: f32,
    pub dir: Vec3,
    pub screen_size_y: f32,
}
*/
layout(binding = 1) uniform UniformBufferObject {
    vec4 pos; // w is screen_size_x
    vec4 dir; // w is screen_size_y
    uint num_chunks;
} render_buffer;

#define POS render_buffer.pos.xyz
#define DIR render_buffer.dir.xyz
#define RES_X render_buffer.pos.w
#define RES_Y render_buffer.dir.w
#define RES vec2(RES_X, RES_Y)
#define NUM_CHUNKS render_buffer.num_chunks

struct ChunkData {
    mat4 transform;
    vec4 aabb_min; // w ist chunk size as u32
    vec4 aabb_max;
};

#define CHUNK_TRANSFORM(chunk_data) chunk_data.transform
#define AABB_MIN(chunk_data) chunk_data.aabb_min.xyz
#define AABB_MAX(chunk_data) chunk_data.aabb_max.xyz
#define CHUNK_SIZE(chunk_data) floatBitsToUint(chunk_data.aabb_min.w)

layout(binding = 2) buffer ChunkDatas {
    ChunkData chunks[];
} chunk_datas;

layout(binding = 3) buffer ChunkNodes {
    uint node_ids[];
} chunk_nodes;

// Voxels
struct Node {
    uint voxels[(NODE_SIZE * NODE_SIZE * NODE_SIZE) / 4];
};

layout(binding = 4) uniform Nodes {
    Node nodes[];
} nodes;

// Materials 
layout(binding = 5) uniform Mats {
    uint mats[];
} mats;


struct Ray{
    vec3 origen;
    vec3 dir;
    vec3 odir; // = 1 / dir
};

Ray init_ray(){
    vec2 uv = ((gl_GlobalInvocationID.xy * 2 - RES) / RES_Y) * vec2(-1);

    vec3 ro = POS;
    vec3 fwd = DIR;
    vec3 up = vec3(0.,0.,1.);
    vec3 right = normalize(cross(up,fwd));
    up = cross(fwd,right);
    vec3 rd = right * uv.x + up * uv.y + fwd;
    rd = normalize(rd);

    Ray ray = Ray(ro, rd, vec3(1) / rd);
    return ray;
}

bool check_aabb_hit(in Ray ray, in vec3 minPos, in vec3 maxPos, out float tMin, out float tMax)
{
    vec3 isPositive = vec3(ray.odir.x > 0, ray.odir.y > 0, ray.odir.z >= 0); // ray.odir = 1.0 / ray.dir
    vec3 isNegative = 1.0f - isPositive;

    vec3 leftSide  = isPositive * minPos + isNegative * maxPos;
    vec3 rightSide = isPositive * maxPos + isNegative * minPos;

    vec3 leftSideTimesOneOverDir  = (leftSide  - ray.origen) * ray.odir;
    vec3 rightSideTimesOneOverDir = (rightSide - ray.origen) * ray.odir;

    tMin = max(leftSideTimesOneOverDir.x, max(leftSideTimesOneOverDir.y, leftSideTimesOneOverDir.z));
    tMax = min(rightSideTimesOneOverDir.x, min(rightSideTimesOneOverDir.y, rightSideTimesOneOverDir.z));

    // vec3 directionSign = sign(odir);
    // sideMin = vec3(leftSideTimesOneOverDir.x == tMin, leftSideTimesOneOverDir.y == tMin, leftSideTimesOneOverDir.z == tMin) * directionSign;
    // sideMax = vec3(rightSideTimesOneOverDir.x == tMax, rightSideTimesOneOverDir.y == tMax, rightSideTimesOneOverDir.z == tMax) * directionSign;

    return tMax > tMin;
}

int next_chunk(in Ray ray, out float t) {
    float best_t = 1000000;
    int best_index = -1;
    for (int i = 0; i < NUM_CHUNKS; i++) {

        ChunkData chunk_data = chunk_datas.chunks[i];

        float t_max;
        if (check_aabb_hit(ray, AABB_MIN(chunk_data), AABB_MAX(chunk_data), t, t_max) && t > 0 && t < best_t) {
            best_t = t;
            best_index = i;
        }
    }

    t = best_t;
    return best_index;
}


// Implementaion inspirend by: https://www.shadertoy.com/view/4dX3zl
bool dda(in Ray ray, in int chunk_index, in float t, out uint step_count) {
    ChunkData chunk_data = chunk_datas.chunks[chunk_index];
    vec3 chunk_pos = (chunk_data.transform * vec4(0, 0, 0, 1)).xyz;
    vec3 global_ray_enter = ray.origen + ray.dir * (t + EPSILON);

    // DDA init
    vec3 local_pos = global_ray_enter - chunk_pos;
    ivec3 cell = ivec3(local_pos);
    vec3 delta_dist = abs(vec3(length(ray.dir)) / ray.dir);
    ivec3 step = ivec3(sign(ray.dir));
    vec3 side_dist = (step * (vec3(cell) - local_pos) + (step * 0.5) + 0.5) * delta_dist;
    bvec3 mask;

    /*
    if (gl_GlobalInvocationID.xy == vec2(640, 360)) {
        debugPrintfEXT("Pos: %f %f %f", local_pos);
    }
    */

    float chunk_size = float(CHUNK_SIZE(chunk_data));
    ivec3 middle = ivec3(chunk_size) / 2;

    ivec3 upper_bound = ivec3(chunk_size);
    step_count = 0;
    while (step_count < MAX_RAY_STEPS) {
        step_count++;

        float dist = distance(cell, middle);
        if (dist < (chunk_size / 4)) {
            return true;
        };

        if (USE_BRANCHLESS_DDA) {
            mask = lessThanEqual(side_dist.xyz, min(side_dist.yzx, side_dist.zxy));
            side_dist += vec3(mask) * delta_dist;
            cell += ivec3(mask) * step;
        }
        else {
            if (side_dist.x < side_dist.y) {
                if (side_dist.x < side_dist.z) {
                    side_dist.x += delta_dist.x;
                    cell.x += step.x;
                    mask = bvec3(true, false, false);
                }
                else {
                    side_dist.z += delta_dist.z;
                    cell.z += step.z;
                    mask = bvec3(false, false, true);
                }
            }
            else {
                if (side_dist.y < side_dist.z) {
                    side_dist.y += delta_dist.y;
                    cell.y += step.y;
                    mask = bvec3(false, true, false);
                }
                else {
                    side_dist.z += delta_dist.z;
                    cell.z += step.z;
                    mask = bvec3(false, false, true);
                }
            }
        }

        if (mask.x && (cell.x <= -1 || cell.x >= upper_bound.x)
            || mask.y && (cell.y <= -1 || cell.y >= upper_bound.x)
            || mask.z && (cell.z <= -1 || cell.z >= upper_bound.x)) {
            return false;
        }
    }

    return false;
}

vec3 step_count_color(in uint step_count) {
    return vec3(1) * (float(step_count) / float(MAX_RAY_STEPS));
}

void main () {
    Ray ray = init_ray();

    float t;
    int next_chunk = next_chunk(ray, t);

    vec3 color = ray.dir;
    if (next_chunk != -1) {
        color *= 0.7;

        uint step_count;
        if (dda(ray, next_chunk, t, step_count)) {

        }

        color = step_count_color(step_count);
    }

    imageStore(img, ivec2(gl_GlobalInvocationID.xy), vec4(color, 0));
}

