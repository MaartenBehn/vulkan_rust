#version 450

#extension GL_AMD_gpu_shader_int16: enable
#extension GL_EXT_shader_explicit_arithmetic_types: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;


// Octtree Start
#define Bit_8_MAX 255
#define Bit_16_MAX 65535

struct Node{
    uint children[8];
    vec4 color; // w is 16 bit Partent Index, 8 bit renderCounter.
};

layout(binding = 0) buffer OcttreeBuffer {
    Node octtree[];
} octtreeBuffer;

layout(binding = 1) buffer OcttreeInfo {
    uint data[]; // 0 is Root index, 1 is buffer Size
} octtreeInfo;


uint getChildIndex(Node node, uint childIndex){
    return uint(node.children[childIndex]);
}
void setChildIndex(uint index, uint childIndex, uint newIndex){
    octtreeBuffer.octtree[index].children[childIndex] = uint(newIndex);
}

vec3 getNodeColor(Node node){
    return vec3(node.color);
}

uint getParentIndex(Node node){
    return floatBitsToUint(node.color.w) & ~(1 << 31);
}
void setParentIndex(uint index, uint parentIndex){

    uint bits = floatBitsToUint(octtreeBuffer.octtree[index].color.w);

    bits = (bits & ~(1 << 31) | parentIndex);

    octtreeBuffer.octtree[index].color.w = uintBitsToFloat(bits);
}

bool getRenderFlag(Node node){
    return bool((uint(floatBitsToUint(node.color.w)) >> 31) & 1); 
}
void setRenderFlag(uint index, bool renderFlag){
    
    uint bits = floatBitsToUint(octtreeBuffer.octtree[index].color.w);

    bits = (bits & ~(1 << 31) | (uint(renderFlag) << 31));

    octtreeBuffer.octtree[index].color.w = uintBitsToFloat(bits);
}

Node getNode(uint index){
    return octtreeBuffer.octtree[index];
}
void setNode(uint index, Node node){
    for (uint i = 0; i < 8; i++){
        setChildIndex(index, i, getChildIndex(node, i));
    }

    octtreeBuffer.octtree[index].color = node.color;
}


uint getRootIndex(){
    return octtreeInfo.data[0];
}
void setRootIndex(uint rootIndex){
    octtreeInfo.data[0] = rootIndex;
}

uint getBufferSize(){
    return octtreeInfo.data[1];
}
// Octtree End


void moveNodeConnections(Node node, uint fromIndex, uint toIndex){
    
}

void main()
{
    uint readHead = 1;
    uint writeHead = 1;
    uint bufferSize = getBufferSize();
    uint rootIndex = getRootIndex();

    uint counter = 0;
    while (counter < 73){
        counter++;

        Node writeNode = getNode(writeHead);
        while (getRenderFlag(writeNode) && writeHead < 73 - 1){
            writeHead++;
            writeNode = getNode(writeHead);
        }

        readHead = max(readHead, writeHead) + 1;

        Node readNode = getNode(readHead);

        if (getRenderFlag(readNode)){

            // Updateing parentIndex of children.
            for (uint i = 0; i < 8; i++){
                uint childIndex = getChildIndex(readNode, i);
                if (childIndex != 0){
                    setParentIndex(childIndex, writeHead);
                }
            }

            for (uint i = 0; i < 8; i++){
                uint childIndex = getChildIndex(writeNode, i);
                if (childIndex != 0){
                    setParentIndex(childIndex, readHead);
                }
            }

            // Updating childIndex of Parent.
            uint readParentIndex = getParentIndex(readNode);
            Node readParentNode = getNode(readParentIndex);
            uint readChildIndex = 8;

            for (uint i = 0; i < 8; i++){
                uint childIndex = getChildIndex(readParentNode, i);
                if (childIndex == readHead){
                    readChildIndex = i;
                    break;
                }
            }

            uint writeParentIndex = getParentIndex(writeNode);
            Node writeParentNode = getNode(writeParentIndex);
            uint writeChildIndex = 8;

            for (uint i = 0; i < 8; i++){
                uint childIndex = getChildIndex(writeParentNode, i);
                if (childIndex == writereHead){
                    writeChildIndex = i;
                    break;
                }
            }

            if (readChildIndex == 8){
                octtreeBuffer.octtree[readHead].color.xyz = vec3(1);
            }
            else{
                setChildIndex(readParentIndex, readChildIndex, writeHead);
            }
            if (writeChildIndex == 8){
                octtreeBuffer.octtree[writeHead].color.xyz = vec3(1);
            }
            else{
                setChildIndex(writeParentIndex, writeChildIndex, readHead);
            }

            
            

            setNode(writeHead, readNode);
            setNode(readHead, writeNode);

            
        }
    }
}