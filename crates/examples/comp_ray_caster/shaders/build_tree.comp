#version 450

#extension GL_AMD_gpu_shader_int16: enable
#extension GL_EXT_shader_explicit_arithmetic_types: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;


// Octtree Start
#define Bit_8_MAX 255
#define Bit_16_MAX 65535


struct Node{
    uint16_t children[8];
    vec4 color; // w is 16 bit Partent Index, 8 bit renderCounter.
};

layout(binding = 0) buffer OcttreeBuffer {
    Node octtree[];
} octtreeBuffer;

layout(binding = 1) uniform OcttreeInfo {
    uvec4 data_0; // 0 is BufferSize, 1 is Buffer Depth, 2 check Index
} octtreeInfo;


uint getChildIndex(Node node, uint childIndex){
    return node.children[childIndex];
}
void setChildIndex(uint index, uint childIndex, uint newIndex){
    octtreeBuffer.octtree[index].children[childIndex] = uint16_t(newIndex);
}

vec3 getNodeColor(Node node){
    return vec3(node.color);
}

uint getParentIndex(Node node){
    return uint(floatBitsToUint(node.color.w) & Bit_16_MAX);
}
void setParentIndex(uint index, uint parentIndex){

    uint bits = floatBitsToUint(octtreeBuffer.octtree[index].color.w);

    bits = (bits & ~(Bit_16_MAX << 0) | (parentIndex << 0));

    octtreeBuffer.octtree[index].color.w = uintBitsToFloat(bits);
}

bool getRenderFlag(Node node){
    return bool((uint(floatBitsToUint(node.color.w)) >> 16) & 1); 
}
void setRenderFlag(uint index, bool renderFlag){
    
    uint bits = floatBitsToUint(octtreeBuffer.octtree[index].color.w);

    bits = (bits & ~(1 << 16) | (uint(renderFlag) << 16));

    octtreeBuffer.octtree[index].color.w = uintBitsToFloat(bits);
}

Node getNode(uint index){
    return octtreeBuffer.octtree[index];
}
void setNode(uint index, Node node){
    for (uint i = 0; i < 8; i++){
        setChildIndex(index, i, getChildIndex(node, i));
    }

    octtreeBuffer.octtree[index].color = node.color;
}


uint getBufferSize(){
    return octtreeInfo.data_0.x;
}
uint getOcttreeDepth(){
    return octtreeInfo.data_0.y;
}
uint getCheckIndex(){
    return octtreeInfo.data_0.z;
}
// Octtree End


void main()
{
    if (gl_GlobalInvocationID.xyz != uvec3(0)){
        return;
    }

    uint writeHead = 1;
    uint readHead = getCheckIndex();
    uint bufferSize = getBufferSize();

    Node writeNode = getNode(writeHead);
    while (getRenderFlag(writeNode) && writeHead < bufferSize - 1){
        writeHead++;
        writeNode = getNode(writeHead);
    }

    if (writeHead >= readHead){
        return;
    }

    Node readNode = getNode(readHead);
    if (getRenderFlag(readNode)){
        
        // Updateing parentIndex of children.
        for (uint i = 0; i < 8; i++){
            uint childIndex = getChildIndex(readNode, i);
            if (childIndex != 0){
                setParentIndex(childIndex, writeHead);
            }
        }

        for (uint i = 0; i < 8; i++){
            uint childIndex = getChildIndex(writeNode, i);
            if (childIndex != 0){
                setParentIndex(childIndex, readHead);
            }
        }
        

        // Updating childIndex of Parent.
        uint readParentIndex = getParentIndex(readNode);
        Node readParentNode = getNode(readParentIndex);
        uint readChildIndex = 8;

        for (uint i = 0; i < 8; i++){
            uint childIndex = getChildIndex(readParentNode, i);
            if (childIndex == readHead){
                readChildIndex = i;
                break;
            }
        }

        uint writeParentIndex = getParentIndex(writeNode);
        Node writeParentNode = getNode(writeParentIndex);
        uint writeChildIndex = 8;

        for (uint i = 0; i < 8; i++){
            uint childIndex = getChildIndex(writeParentNode, i);
            if (childIndex == writeHead){
                writeChildIndex = i;
                break;
            }
        }
        
        if (readChildIndex == 8){
            octtreeBuffer.octtree[readHead].color.xyz = vec3(1);
        }
        else{
            setChildIndex(readParentIndex, readChildIndex, writeHead);
        }
        if (writeChildIndex == 8){
            octtreeBuffer.octtree[writeHead].color.xyz = vec3(1);
        }
        else{
            setChildIndex(writeParentIndex, writeChildIndex, readHead);
        }

        setNode(readHead, writeNode);
        setNode(writeHead, readNode);
    }
}