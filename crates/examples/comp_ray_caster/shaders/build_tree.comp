#version 450

#extension GL_AMD_gpu_shader_int16: enable
#extension GL_EXT_shader_explicit_arithmetic_types: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;


// Octtree Start
#define Bit_8_MAX 255
#define Bit_16_MAX 65535

struct Node{
    uint16_t children[8];
    uvec4 dynamik_data; // 0: Parent Index, 1: PNext 2: PLast
    uvec4 static_data;
};

layout(std430, binding = 0) buffer OcttreeBuffer {
    Node octtree[];
} octtreeBuffer;

layout(binding = 1) uniform OcttreeInfo {
    uvec4 data_0;
    uvec4 data_1;
} octtreeInfo;

// Dynamik Data
uint getChildIndex(Node node, uint childIndex){
    return node.children[childIndex];
}
uint getChildIndex(uint index, uint childIndex){
    return octtreeBuffer.octtree[index].children[childIndex];
}
void setChildIndex(uint index, uint childIndex, uint newIndex){
    octtreeBuffer.octtree[index].children[childIndex] = uint16_t(newIndex);
}

uint getParentIndex(Node node){
    return node.dynamik_data[0];
}
uint getParentIndex(uint index){
    return octtreeBuffer.octtree[index].dynamik_data[0];
}
uint setParentIndex(uint index, uint parentIndex){
    return octtreeBuffer.octtree[index].dynamik_data[0] = parentIndex;
}

uint getPNext(Node node){
    return node.dynamik_data[1];
}
uint getPNext(uint index){
    return octtreeBuffer.octtree[index].dynamik_data[1];
}
void setPNext(uint index, uint pNext){
    octtreeBuffer.octtree[index].dynamik_data[1] = pNext;
}

uint getPLast(Node node){
    return node.dynamik_data[2];
}
uint getPLast(uint index){
    return octtreeBuffer.octtree[index].dynamik_data[2];
}
void setPLast(uint index, uint pLast){
    octtreeBuffer.octtree[index].dynamik_data[2] = pLast;
}

bool getRenderFlag(Node node){
    return bool(node.dynamik_data[3] & 1);
}
bool getRenderFlag(uint index){
    return bool(octtreeBuffer.octtree[index].dynamik_data[3] & 1);
}
void setRenderFlag(uint index){
    octtreeBuffer.octtree[index].dynamik_data[3] |= 1;
}
void resetRenderFlag(uint index){
    octtreeBuffer.octtree[index].dynamik_data[3] &= ~1;
}

bool getNeedsChildrenFlag(Node node, uint childNr){
    return bool(node.dynamik_data[3] & (1 << (16 + childNr)));
}
bool getNeedsChildrenFlag(uint index, uint childNr){
    return bool(octtreeBuffer.octtree[index].dynamik_data[3] & (1 << (16 + childNr)));
}
void setNeedsChildrenFlag(uint index, uint childNr){
    octtreeBuffer.octtree[index].dynamik_data[3] |= (1 << (16 + childNr));
}
void resetNeedsChildrenFlag(uint index){
    octtreeBuffer.octtree[index].dynamik_data[3] &= ~(Bit_16_MAX << 16);
}

Node getNode(uint index){
    return octtreeBuffer.octtree[index];
}
void setNode(Node node, uint index){
    octtreeBuffer.octtree[index] = node;
}

// Static Data
uint getNodeId(Node node){
    return node.static_data[0];
}
uint getNodeId(uint index){
    return octtreeBuffer.octtree[index].static_data[0];
}
void setNodeId(Node node, uint id){
    node.static_data[0] = id;
}

uint getNodeMaterial(Node node){
    return node.static_data[2];
}
uint getNodeMaterial(uint index){
    return octtreeBuffer.octtree[index].static_data[2];
}
void setNodeMaterial(Node node, uint index){
    node.static_data[2] = index;
}

uint getNodeDepth(Node node){
    return node.static_data[3];
}
uint getNodeDepth(uint index){
    return octtreeBuffer.octtree[index].static_data[3];
}
void setNodeDepth(Node node, uint depth){
    node.static_data[3] = depth;
}

// Octtree Info
uint getTreeSize(){
    return octtreeInfo.data_0[0];
}
uint getBufferSize(){
    return octtreeInfo.data_0[1];
}
uint getTransferBufferSize(){
    return octtreeInfo.data_0[2];
}
uint getOcttreeDepth(){
    return octtreeInfo.data_0[3];
}
uint getBuildOffset(){
    return octtreeInfo.data_1[0];
}
uint getReBuild(){
    return octtreeInfo.data_1[1];
}
// Octtree End

void reBuild(uint index){

    uint bufferSize = getBufferSize();

    uint is_start = uint(index == 0);
    uint is_end = uint(index == bufferSize -1);

    uint p_next = index + 1 * (1 - is_end);
    uint p_last = index - 1 * (1 - is_start) + (bufferSize - 1) * is_start;

    Node node = Node(
        uint16_t[8](uint16_t(0),uint16_t(0),uint16_t(0),uint16_t(0), uint16_t(0),uint16_t(0),uint16_t(0),uint16_t(0)),
        uvec4(bufferSize, p_next, p_last, 0),
        uvec4(0, 0, 1, 0)
    );
    setNode(node, index);
}

uint getChildId(uint nodeId, uint childNr, uint depth){
    int childSize = int((1 - pow(8, depth)) / -7);
    return uint(nodeId + childSize * childNr + 1);
}

void buildNode(uint nodeIndex){
    uint bufferSize = getBufferSize();
    uint octtreeDepth = getOcttreeDepth();
    uint depth = getNodeDepth(nodeIndex);

    for (uint childNr = 0; childNr < 8; childNr++){
        uint newChildIndex = 0;

        if (octtreeDepth > depth) {
            uint childId = getChildId(getNodeId(nodeIndex), childNr, octtreeDepth - depth);
    
            for (uint childIndex = 0; childIndex < bufferSize; childIndex++){
                if (getNodeId(childIndex) == childId){
                    newChildIndex = childIndex;
                    break;
                }
            }
        }
        
        setChildIndex(nodeIndex, childNr, newChildIndex);

        if (newChildIndex != 0) {
            setParentIndex(newChildIndex, nodeIndex);
        }
    }
}

void main()
{
    uint nodeIndex = gl_GlobalInvocationID.x + getBuildOffset();

    if (getReBuild() == 1){
        reBuild(nodeIndex);
    }else{
        buildNode(nodeIndex);
    }
}