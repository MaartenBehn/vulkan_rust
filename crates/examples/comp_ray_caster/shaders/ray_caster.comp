#version 450
#extension GL_AMD_gpu_shader_int16: enable
#extension GL_EXT_shader_explicit_arithmetic_types: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

struct Node{
    uint16_t children[8];
    uvec4 pos; // w is the depth
    vec4 color; // w is the parent index and data bit field
};

layout(binding = 0, rgba8) uniform writeonly image2D img;

layout(binding = 1) uniform UniformBufferObject {
    vec2 screen_size;
    vec3 pos;
    vec3 dir;
} ubo;

layout(binding = 2) buffer OcttreeBuffer {
    Node octtree[];
} octtreeBuffer;

#define BUFFER_DEBUG false
#define OCTTREE_SIZE 16
#define VIEW_DIST 10


uint getParent(Node node){
    return uint(floatBitsToUint(node.color.w));
}
uint getDepth(Node node){
    return uint(node.pos.w);
}

void draw_buffer_debuger(){
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = gl_GlobalInvocationID.xy / ubo.screen_size;
    Node node = octtreeBuffer.octtree[gl_GlobalInvocationID.x];
    
    vec3 color = vec3(0);
    if (uv.y < 0.1) {
        color = vec3(node.children[0]) / vec3(4681);
    }
    else if (uv.y < 0.2) {
        color = vec3(getParent(node));
    }
    else if (uv.y < 0.3) {
        color = vec3(node.pos.x) / vec3(16);
    }
    else if (uv.y < 0.4) {
        color = vec3(node.pos.y) / vec3(16);
    }
    else if (uv.y < 0.5) {
        color = vec3(node.pos.z) / vec3(16);
    }
    else if (uv.y < 0.6) {
        color = vec3(getDepth(node)) / vec3(4);
    }
    else if (uv.y < 0.7) {
        color = node.color.xyz;
    }
    imageStore(img, ivec2(gl_GlobalInvocationID.xy), vec4(color, 0));
}


/*
uint to1D( uvec3 v ) {
    return (v.z * MAX_X * MAX_Y) + (v.y * MAX_X) + v.x;
}

uint16_t[] to3D( uint16_t idx ) {
    final int z = idx / (xMax * yMax);
    idx -= (z * xMax * yMax);
    final int y = idx / xMax;
    final int x = idx % xMax;
    return new int[]{ x, y, z };
}
*/


struct Ray{
    vec3 origin;
    vec3 dir;
};

vec3 saturate(vec3 v){
    return clamp(v, 0.0, 1.0);
}

bool checkHit(in Ray ray, in vec3 pos, in vec3 size, out float tMin, out float tMax, out vec3 sideMin, out vec3 sideMax)
{
    vec3 minSize = pos;
    vec3 maxSize = pos + size;
    vec3 odir = vec3(1) / (ray.dir);

    vec3 isPositive = vec3(odir.x > 0, odir.y > 0, odir.z >= 0); // ray.odir = 1.0 / ray.dir
    vec3 isNegative = 1.0f - isPositive;

    vec3 leftSide  = isPositive * minSize + isNegative * maxSize;
    vec3 rightSide = isPositive * maxSize + isNegative * minSize;

    vec3 leftSideTimesOneOverDir  = (leftSide  - ray.origin) * odir;
    vec3 rightSideTimesOneOverDir = (rightSide - ray.origin) * odir;

    tMin = max(leftSideTimesOneOverDir.x, max(leftSideTimesOneOverDir.y, leftSideTimesOneOverDir.z));
    tMax = min(rightSideTimesOneOverDir.x, min(rightSideTimesOneOverDir.y, rightSideTimesOneOverDir.z));

    vec3 directionSign = sign(odir);

    sideMin = vec3(leftSideTimesOneOverDir.x == tMin, leftSideTimesOneOverDir.y == tMin, leftSideTimesOneOverDir.z == tMin) * directionSign;
    sideMax = vec3(rightSideTimesOneOverDir.x == tMax, rightSideTimesOneOverDir.y == tMax, rightSideTimesOneOverDir.z == tMax) * directionSign;

    return tMax > tMin;
}


void main () {
    if (BUFFER_DEBUG) {
        draw_buffer_debuger();
        return;
    }

    vec2 uv = (gl_GlobalInvocationID.xy * 2 - ubo.screen_size.xy) / ubo.screen_size.y;

    vec3 ro = ubo.pos * vec3(-1);
    vec3 fwd = ubo.dir;
    vec3 up = vec3(0.,1.,0.);
    vec3 right = normalize(cross(up,fwd));
    up = cross(fwd,right);
    vec3 rd = right * uv.x + up * uv.y + fwd;
    rd = normalize(rd);

    Ray ray = Ray(ro, rd);

    float tMin;
    float tMax;
    vec3 sideMin;
    vec3 sideMax;

    bool hit = checkHit(ray, vec3(-0.5), vec3(1), tMin, tMax, sideMin, sideMax);

    float depth = (1 - (tMin / VIEW_DIST)) * float(hit);

    imageStore(img, ivec2(gl_GlobalInvocationID.xy), vec4(vec3(depth), 0));
}

