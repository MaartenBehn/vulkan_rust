#version 450
#extension GL_AMD_gpu_shader_int16: enable
#extension GL_EXT_shader_explicit_arithmetic_types: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

struct Node{
    uint16_t children[8];

    uvec4 pos; // w is the depth

    vec4 color; // w is the parent index as uint

    uint childIndex;
    vec2 fill;
};

layout(binding = 0, rgba8) uniform writeonly image2D img;

layout(binding = 1) uniform UniformBufferObject {
    vec2 screen_size;
    vec3 pos;
    vec3 dir;
} ubo;

layout(binding = 2) buffer OcttreeBuffer {
    Node octtree[];
} octtreeBuffer;

#define BUFFER_DEBUG false
#define OCTTREE_SIZE 16
#define OCTTREE_DEPTH 4
#define VIEW_DIST 100


uint getParent(Node node){
    return uint(floatBitsToUint(node.color.w));
}
uint getNodeDepth(Node node){
    return uint(node.pos.w);
}

vec3 getNodeColor(Node node){
    return vec3(node.color);
}

void draw_buffer_debuger(){
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = gl_GlobalInvocationID.xy / ubo.screen_size;
    Node node = octtreeBuffer.octtree[gl_GlobalInvocationID.x / 10];
    
    vec3 color = vec3(0);
    if (uv.y < 0.1) {
        color = vec3(node.children[0]) / vec3(4681);
    }
    else if (uv.y < 0.2) {
        color = vec3(getParent(node)) / vec3(4681);
    }
    else if (uv.y < 0.3) {
        color = vec3(node.childIndex) / vec3(8);
    }
    else if (uv.y < 0.4) {
        color = vec3(node.pos.x) / vec3(16);
    }
    else if (uv.y < 0.5) {
        color = vec3(node.pos.y) / vec3(16);
    }
    else if (uv.y < 0.6) {
        color = vec3(node.pos.z) / vec3(16);
    }
    else if (uv.y < 0.7) {
        color = vec3(getNodeDepth(node)) / vec3(4);
    }
    else if (uv.y < 0.8) {
        color = node.color.xyz;
    }
    imageStore(img, ivec2(gl_GlobalInvocationID.xy), vec4(color, 0));
}


/*
uint to1D( uvec3 v ) {
    return (v.z * MAX_X * MAX_Y) + (v.y * MAX_X) + v.x;
}

uint16_t[] to3D( uint16_t idx ) {
    final int z = idx / (xMax * yMax);
    idx -= (z * xMax * yMax);
    final int y = idx / xMax;
    final int x = idx % xMax;
    return new int[]{ x, y, z };
}
*/


struct Ray{
    vec3 pos;
    vec3 dir;
};



Ray initRay(){
    vec2 uv = ((gl_GlobalInvocationID.xy * 2 - ubo.screen_size.xy) / ubo.screen_size.y) * vec2(-1);

    vec3 ro = ubo.pos;
    vec3 fwd = ubo.dir;
    vec3 up = vec3(0.,1.,0.);
    vec3 right = normalize(cross(up,fwd));
    up = cross(fwd,right);
    vec3 rd = right * uv.x + up * uv.y + fwd;
    rd = normalize(rd);

    Ray ray = Ray(ro, rd);
    return ray;
}

bool checkHit(in Ray ray, in Node node, out float tMin, out float tMax, out vec3 sideMin, out vec3 sideMax)
{
    vec3 minSize = vec3(node.pos);
    vec3 maxSize = vec3(node.pos) + vec3(pow(2, OCTTREE_DEPTH - getNodeDepth(node)));
    vec3 odir = vec3(1) / (ray.dir);

    vec3 isPositive = vec3(odir.x > 0, odir.y > 0, odir.z >= 0); // ray.odir = 1.0 / ray.dir
    vec3 isNegative = 1.0f - isPositive;

    vec3 leftSide  = isPositive * minSize + isNegative * maxSize;
    vec3 rightSide = isPositive * maxSize + isNegative * minSize;

    vec3 leftSideTimesOneOverDir  = (leftSide  - ray.pos) * odir;
    vec3 rightSideTimesOneOverDir = (rightSide - ray.pos) * odir;

    tMin = max(leftSideTimesOneOverDir.x, max(leftSideTimesOneOverDir.y, leftSideTimesOneOverDir.z));
    tMax = min(rightSideTimesOneOverDir.x, min(rightSideTimesOneOverDir.y, rightSideTimesOneOverDir.z));

    vec3 directionSign = sign(odir);

    sideMin = vec3(leftSideTimesOneOverDir.x == tMin, leftSideTimesOneOverDir.y == tMin, leftSideTimesOneOverDir.z == tMin) * directionSign;
    sideMax = vec3(rightSideTimesOneOverDir.x == tMax, rightSideTimesOneOverDir.y == tMax, rightSideTimesOneOverDir.z == tMax) * directionSign;

    return tMax > tMin;
}


/*
Child Offset:
0  [0, 0, 0],
1  [0, 0, 1],
2  [0, 1, 0],
3  [0, 1, 1],

4  [1, 0, 0],
5  [1, 0, 1],
6  [1, 1, 0],
7  [1, 1, 1],

Side:
0  [0, 0, 1]
1  [0, 1, 0]
2  [1, 0, 0]

3  [0, 0,-1]
4  [0,-1, 0]
5  [-1, 0, 0]
*/

uvec3 getNodePos(vec3 pos, uint depth){
    uvec3 size = uvec3(pow(2, OCTTREE_DEPTH - depth));
    uvec3 nodePos = (uvec3(pos / size) - uvec3(pos.x < 0, pos.y < 0, pos.z < 0)) * size;
    return nodePos;
}

Node getChildFromAtPos(Node node, vec3 pos, uint depth){
    uvec3 nodePos = getNodePos(pos, depth);

    for (uint i = 0; i < 8; i++){
        Node childNode = octtreeBuffer.octtree[node.children[i]];
        if (uvec3(childNode.pos) == nodePos){
            return childNode;
        }
    }

    return node;
}

bool hitOctree(in Ray ray, out vec3 color){

    float tMin;
    float tMax;
    vec3 sideMin;
    vec3 sideMax;
    uint depth = 0;
    float rayLen = 0;

    color = vec3(0);
    Node root = octtreeBuffer.octtree[0];

    if (getNodePos(ray.pos, 0) != uvec3(0)){
        bool initalHit = checkHit(ray, root, tMin, tMax, sideMin, sideMax);

        if (!initalHit || (tMin < 0) || (tMax < 0)){
            return false;
        }
        else{
            ray.pos = ray.pos + ray.dir * (tMin + 0.0001);
            rayLen += tMin;
        }
    }

    Node node = root;

    uint counter = 0;
    while(counter < 100){
        bool isEmpty = getNodeColor(node) == vec3(0);
        bool isLeave = depth >= (OCTTREE_DEPTH - (rayLen * 0.03));

        if (!isEmpty && isLeave){
            color = getNodeColor(node);
            return true; // Ray Hit Node to Render

        }
        else if (isEmpty){
            checkHit(ray, node, tMin, tMax, sideMin, sideMax);
            ray.pos = ray.pos + ray.dir * (tMax + 0.0001);
            rayLen += tMax;

            if (getNodePos(ray.pos, 0) == uvec3(0)){
                node = root;
                depth = 0;
            }
            else{
                color = vec3(0.1, 0.1, 0);
                return true; // Ray left Tree.
            }
        }
        else if (!isEmpty && !isLeave){
            depth += 1;

            node = getChildFromAtPos(node, ray.pos, depth);
        }

        counter++;
    }

    color = vec3(0.1, 0, 0.1);
    return true; // Stopped loop
}


void main () { 
    if (BUFFER_DEBUG) {
        draw_buffer_debuger();
        return;
    }

    Ray ray = initRay();

    vec3 color;

    bool hit = hitOctree(ray, color);

    imageStore(img, ivec2(gl_GlobalInvocationID.xy), vec4((color) * float(hit) , 0));
}

