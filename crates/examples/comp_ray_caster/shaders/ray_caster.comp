#version 450
#extension GL_AMD_gpu_shader_int16: enable
#extension GL_EXT_shader_explicit_arithmetic_types: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(binding = 0, rgba8) uniform writeonly image2D img;

layout(binding = 1) uniform UniformBufferObject {
    vec4 screen_size; // z is mode as u32, w is cleanup bool as u32
    vec3 pos;
    vec3 dir;
} ubo;

uint getMode(){
    return uint(floatBitsToUint(ubo.screen_size.z));
}

bool getCleanUp(){
    return bool(floatBitsToUint(ubo.screen_size.w));
}

// Octtree Start
#define Bit_8_MAX 255
#define Bit_16_MAX 65535


struct Node{
    uint16_t children[8];
    vec4 color; // w is 16 bit Partent Index, 8 bit renderCounter.
};

layout(binding = 2) buffer OcttreeBuffer {
    Node octtree[];
} octtreeBuffer;

layout(binding = 3) uniform OcttreeInfo {
    uvec4 data_0; // 0 is BufferSize, 1 is Buffer Depth, 2 check Index
} octtreeInfo;


uint getChildIndex(Node node, uint childIndex){
    return node.children[childIndex];
}
void setChildIndex(uint index, uint childIndex, uint newIndex){
    octtreeBuffer.octtree[index].children[childIndex] = uint16_t(newIndex);
}

vec3 getNodeColor(Node node){
    return vec3(node.color);
}

uint getParentIndex(Node node){
    return uint(floatBitsToUint(node.color.w) & Bit_16_MAX);
}
void setParentIndex(uint index, uint parentIndex){

    uint bits = floatBitsToUint(octtreeBuffer.octtree[index].color.w);

    bits = (bits & ~(Bit_16_MAX << 0) | (parentIndex << 0));

    octtreeBuffer.octtree[index].color.w = uintBitsToFloat(bits);
}

bool getRenderFlag(Node node){
    return bool((uint(floatBitsToUint(node.color.w)) >> 16) & 1); 
}
void setRenderFlag(uint index, bool renderFlag){
    
    uint bits = floatBitsToUint(octtreeBuffer.octtree[index].color.w);

    bits = (bits & ~(1 << 16) | (uint(renderFlag) << 16));

    octtreeBuffer.octtree[index].color.w = uintBitsToFloat(bits);
}

Node getNode(uint index){
    return octtreeBuffer.octtree[index];
}
void setNode(uint index, Node node){
    for (uint i = 0; i < 8; i++){
        setChildIndex(index, i, getChildIndex(node, i));
    }

    octtreeBuffer.octtree[index].color = node.color;
}


uint getBufferSize(){
    return octtreeInfo.data_0.x;
}
uint getOcttreeDepth(){
    return octtreeInfo.data_0.y;
}
uint getCheckIndex(){
    return octtreeInfo.data_0.z;
}
// Octtree End

#define VIEW_DIST 100
#define MAX_STEPS 100


vec3 getColorGradient(float x){
    if (x == 0){
        return vec3(0);
    }

    vec3 firstColor = vec3(0, 1, 0); // greee
    vec3 middleColor = vec3(0, 0, 1); // blue
    vec3 endColor = vec3(1, 0, 0); // red

    float h = 0.5; // adjust position of middleColor
    vec3 col = mix(mix(firstColor, middleColor, x/h), mix(middleColor, endColor, (x - h)/(1.0 - h)), step(h, x));
    return col;
}

vec3 draw_buffer_debuger(){
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = gl_GlobalInvocationID.xy / ubo.screen_size.xy;


    uint nodeIndex = gl_GlobalInvocationID.x / 20;
    Node node = getNode(nodeIndex);
    
    vec3 color = vec3(0);
    if (uv.y < 0.1) {
        color = getColorGradient(float(nodeIndex) / float(getBufferSize()));
    }
    else if (uv.y < 0.15) {
        color = getColorGradient(float(getChildIndex(node, 0)) / float(getBufferSize()));
    }
    else if (uv.y < 0.2) {
        color = getColorGradient(float(getChildIndex(node, 1)) / float(getBufferSize()));
    }
    else if (uv.y < 0.25) {
        color = getColorGradient(float(getChildIndex(node, 2)) / float(getBufferSize()));
    }
    else if (uv.y < 0.3) {
        color = getColorGradient(float(getChildIndex(node, 3)) / float(getBufferSize()));
    }
    else if (uv.y < 0.35) {
        color = getColorGradient(float(getChildIndex(node, 4)) / float(getBufferSize()));
    }
    else if (uv.y < 0.4) {
        color = getColorGradient(float(getChildIndex(node, 5)) / float(getBufferSize()));
    }
    else if (uv.y < 0.45) {
        color = getColorGradient(float(getChildIndex(node, 6)) / float(getBufferSize()));
    }
    else if (uv.y < 0.5) {
        color = getColorGradient(float(getChildIndex(node, 7)) / float(getBufferSize()));
    }
    else if (uv.y < 0.6) {
        color = getColorGradient(float(getParentIndex(node)) / float(getBufferSize()));
    }
    else if (uv.y < 0.7) {
        color = getNodeColor(node);
    }
    else if (uv.y < 0.8) {
        color = vec3(getRenderFlag(node));
    }
    else if (uv.y < 0.85) {
        color = vec3(nodeIndex == getCheckIndex());
    }
    return color;
}

void cleanUpRenderFlag(){
    if (getCleanUp() && gl_GlobalInvocationID.xy == uvec2(0)) {
        for (uint i = 0; i < 4681; i++){
            setRenderFlag(i, false);
        }
    }
}

struct Ray{
    vec3 pos;
    vec3 dir;
    vec3 odir; // = 1 / dir
};

Ray initRay(){
    vec2 uv = ((gl_GlobalInvocationID.xy * 2 - ubo.screen_size.xy) / ubo.screen_size.y) * vec2(-1);

    vec3 ro = ubo.pos.xyz;
    vec3 fwd = ubo.dir.xyz;
    vec3 up = vec3(0.,1.,0.);
    vec3 right = normalize(cross(up,fwd));
    up = cross(fwd,right);
    vec3 rd = right * uv.x + up * uv.y + fwd;
    rd = normalize(rd);

    Ray ray = Ray(ro, rd, vec3(1) / rd);
    return ray;
}

bool checkHit(in Ray ray, in vec3 nodePos, in uint size, out float tMin, out float tMax)
{
    vec3 minSize = nodePos;
    vec3 maxSize = nodePos + vec3(size);

    vec3 isPositive = vec3(ray.odir.x > 0, ray.odir.y > 0, ray.odir.z >= 0); // ray.odir = 1.0 / ray.dir
    vec3 isNegative = 1.0f - isPositive;

    vec3 leftSide  = isPositive * minSize + isNegative * maxSize;
    vec3 rightSide = isPositive * maxSize + isNegative * minSize;

    vec3 leftSideTimesOneOverDir  = (leftSide  - ray.pos) * ray.odir;
    vec3 rightSideTimesOneOverDir = (rightSide - ray.pos) * ray.odir;

    tMin = max(leftSideTimesOneOverDir.x, max(leftSideTimesOneOverDir.y, leftSideTimesOneOverDir.z));
    tMax = min(rightSideTimesOneOverDir.x, min(rightSideTimesOneOverDir.y, rightSideTimesOneOverDir.z));

    // vec3 directionSign = sign(odir);

    // sideMin = vec3(leftSideTimesOneOverDir.x == tMin, leftSideTimesOneOverDir.y == tMin, leftSideTimesOneOverDir.z == tMin) * directionSign;
    // sideMax = vec3(rightSideTimesOneOverDir.x == tMax, rightSideTimesOneOverDir.y == tMax, rightSideTimesOneOverDir.z == tMax) * directionSign;

    return tMax > tMin;
}


/*
Child Offset:
0  [0, 0, 0],
1  [0, 0, 1],
2  [0, 1, 0],
3  [0, 1, 1],

4  [1, 0, 0],
5  [1, 0, 1],
6  [1, 1, 0],
7  [1, 1, 1],

Side:
0  [0, 0, 1]
1  [0, 1, 0]
2  [1, 0, 0]

3  [0, 0,-1]
4  [0,-1, 0]
5  [-1, 0, 0]
*/

uvec3 getNodePos(vec3 pos, uint size){
    uvec3 nodePos = (uvec3(pos / size) - uvec3(pos.x < 0, pos.y < 0, pos.z < 0)) * size;
    return nodePos;
}

uint getChildFromPos(uvec3 pos){
    return pos.x * 4 + pos.y * 2 + pos.z;
}

uint getSizeFromDepth(uint depth){
    return uint(pow(2, getOcttreeDepth() - depth));
}

bool hitOctree(in Ray ray, out vec3 color, out uint counter){

    float tMin;
    float tMax;
    float rayLen = 0;
    uint rootSize = getSizeFromDepth(0);
    
    // Inital Check
    if (getNodePos(ray.pos, rootSize) != uvec3(0)){
        bool initalHit = checkHit(ray, vec3(0, 0, 0), rootSize, tMin, tMax);

        if (!initalHit || (tMin < 0) || (tMax < 0)){
            return false;
        }
        else{
            ray.pos = ray.pos + ray.dir * (tMin + 0.0001);
            rayLen += tMin;
        }
    }

    // Loop
    uint depth = 0;
    uint size = rootSize;

    setRenderFlag(0, true);
    Node root = getNode(0);
    Node node = root;
    uvec3 nodePos = uvec3(0);


    color = vec3(0);
    counter = 0;
    
    while(counter < MAX_STEPS){
        bool isEmpty = getNodeColor(node) == vec3(0);
        bool isLeave = depth >= (getOcttreeDepth() - (rayLen * 0.03));

        if (!isEmpty && !isLeave){
            depth += 1;
            size = getSizeFromDepth(depth);

            uvec3 newNodePos = getNodePos(ray.pos, size);
            uvec3 posDelta = (newNodePos - nodePos) / (size); 
            nodePos = newNodePos;

            if (posDelta.x < 0 || posDelta.x > 1 || posDelta.y < 0 || posDelta.y > 1 || posDelta.z < 0 || posDelta.z > 1){
                color = vec3(1, 0, 0.5);
                return true;
            }

            uint childIndex = getChildFromPos(posDelta);
            uint newNodeIndex = node.children[childIndex];

            setRenderFlag(newNodeIndex, true);
            node = getNode(newNodeIndex);
        }
        else if (isEmpty){
            checkHit(ray, vec3(nodePos), size, tMin, tMax);
            ray.pos = ray.pos + ray.dir * (tMax + 0.0001);
            rayLen += tMax;

            if (getNodePos(ray.pos, rootSize) == uvec3(0)){
                node = root;
                depth = 0;
                size = rootSize;
                nodePos = uvec3(0);
            }
            else{
                return false; // Ray left Tree.
            }
        }
        else if (!isEmpty && isLeave){
            color = getNodeColor(node);
            return true; // Ray Hit Node to Render
        }

        counter++;
    }

    return false; // Stopped loop
}

void main () { 
    vec3 color;
    if (getMode() == 0) {
        color = draw_buffer_debuger();
        
    }
    else{
        cleanUpRenderFlag();

        Ray ray = initRay();

        uint counter;
        bool hit = hitOctree(ray, color, counter);

        if (getMode() == 2) {
            color = getColorGradient((float(counter) / MAX_STEPS));
        }

        color *= float(hit);

        if (getMode() == 3) {
            color += draw_buffer_debuger() * 0.5;
        }
    }

    imageStore(img, ivec2(gl_GlobalInvocationID.xy), vec4(color, 0));
}

