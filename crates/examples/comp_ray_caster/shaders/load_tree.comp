#version 450

#extension GL_AMD_gpu_shader_int16: enable
#extension GL_EXT_shader_explicit_arithmetic_types: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;


// Octtree Start
#define Bit_8_MAX 255
#define Bit_16_MAX 65535

struct Node{
    uint16_t children[8];
    uvec4 dynamik_data;
    uvec4 static_data;
};

layout(std430, binding = 0) buffer OcttreeBuffer {
    Node octtree[];
} octtreeBuffer;

layout(binding = 1) uniform OcttreeInfo {
    uvec4 data_0;
    uvec4 data_1;
} octtreeInfo;

// Dynamik Data
uint getChildIndex(Node node, uint childIndex){
    return node.children[childIndex];
}
uint getChildIndex(uint index, uint childIndex){
    return octtreeBuffer.octtree[index].children[childIndex];
}
void setChildIndex(uint index, uint childIndex, uint newIndex){
    octtreeBuffer.octtree[index].children[childIndex] = uint16_t(newIndex);
}

uint getParentIndex(Node node){
    return node.dynamik_data[0];
}
uint getParentIndex(uint index){
    return octtreeBuffer.octtree[index].dynamik_data[0];
}
uint setParentIndex(uint index, uint parentIndex){
    return octtreeBuffer.octtree[index].dynamik_data[0] = parentIndex;
}

uint getPNext(Node node){
    return node.dynamik_data[1];
}
uint getPNext(uint index){
    return octtreeBuffer.octtree[index].dynamik_data[1];
}
void setPNext(uint index, uint pNext){
    octtreeBuffer.octtree[index].dynamik_data[1] = pNext;
}

uint getPLast(Node node){
    return node.dynamik_data[2];
}
uint getPLast(uint index){
    return octtreeBuffer.octtree[index].dynamik_data[2];
}
void setPLast(uint index, uint pLast){
    octtreeBuffer.octtree[index].dynamik_data[2] = pLast;
}

bool getRenderFlag(Node node){
    return bool(node.dynamik_data[3] & 1);
}
bool getRenderFlag(uint index){
    return bool(octtreeBuffer.octtree[index].dynamik_data[3] & 1);
}
void setRenderFlag(uint index){
    octtreeBuffer.octtree[index].dynamik_data[3] |= 1;
}
void resetRenderFlag(uint index){
    octtreeBuffer.octtree[index].dynamik_data[3] &= ~1;
}

bool getNeedsChildrenFlag(Node node, uint childNr){
    return bool(node.dynamik_data[3] & (1 << (16 + childNr)));
}
bool getNeedsChildrenFlag(uint index, uint childNr){
    return bool(octtreeBuffer.octtree[index].dynamik_data[3] & (1 << (16 + childNr)));
}
void setNeedsChildrenFlag(uint index, uint childNr){
    octtreeBuffer.octtree[index].dynamik_data[3] |= (1 << (16 + childNr));
}
void resetNeedsChildrenFlag(uint index){
    octtreeBuffer.octtree[index].dynamik_data[3] &= ~(Bit_16_MAX << 16);
}

Node getNode(uint index){
    return octtreeBuffer.octtree[index];
}
void setNode(uint index, Node node){
    octtreeBuffer.octtree[index] = node;
}

// Static Data
uint getNodeId(Node node){
    return node.static_data[0];
}
uint getNodeId(uint index){
    return octtreeBuffer.octtree[index].static_data[0];
}

uint getNodeMaterial(Node node){
    return node.static_data[2];
}
uint getNodeMaterial(uint index){
    return octtreeBuffer.octtree[index].static_data[2];
}

uint getNodeDepth(Node node){
    return node.static_data[3];
}
uint getNodeDepth(uint index){
    return octtreeBuffer.octtree[index].static_data[3];
}

// Octtree Info
uint getTreeSize(){
    return octtreeInfo.data_0[0];
}
uint getBufferSize(){
    return octtreeInfo.data_0[1];
}
uint getTransferBufferSize(){
    return octtreeInfo.data_0[2];
}
uint getOcttreeDepth(){
    return octtreeInfo.data_0[3];
}
uint getBuildOffset(){
    return octtreeInfo.data_1[0];
}
// Octtree End

layout(binding = 2) buffer TransferBuffer {
    Node nodes[];
} transferBuffer;

layout(binding = 3) buffer RequestBuffer {
    uint nodes[];
} requestBuffer;


// Linked List Operations
void extractNode(uint nodeIndex){
    uint p_last = getPLast(nodeIndex);
    uint p_next = getPNext(nodeIndex);

    setPNext(p_last, p_next);
    setPLast(p_next, p_last);
}

void insterNodeAfter(uint nodeIndex, uint afterIndex){
    uint after_p_next = getPNext(afterIndex);
    
    setPNext(afterIndex, nodeIndex);
    setPLast(nodeIndex, afterIndex);

    setPNext(nodeIndex, after_p_next);
    setPLast(after_p_next, nodeIndex);
}

uint getChildId(uint nodeId, uint childNr, uint depth){
    int childSize = int((1 - pow(8, depth)) / -7);
    return uint(nodeId + childSize * childNr + 1);
}

void buildNode(uint nodeIndex){
    uint bufferSize = getBufferSize();
    uint octtreeDepth = getOcttreeDepth();
    uint depth = getNodeDepth(nodeIndex);

    for (uint childNr = 0; childNr < 8; childNr++){
        uint newChildIndex = 0;

        if (octtreeDepth > depth) {
            uint childId = getChildId(getNodeId(nodeIndex), childNr, octtreeDepth - depth);
    
            for (uint childIndex = 0; childIndex < bufferSize; childIndex++){
                if (getNodeId(childIndex) == childId){
                    newChildIndex = childIndex;
                    break;
                }
            }

            if (newChildIndex == 0){
                newChildIndex = bufferSize;
            }
        }
        
        setChildIndex(nodeIndex, childNr, newChildIndex);

        if (newChildIndex != 0 && newChildIndex != bufferSize) {
            setParentIndex(newChildIndex, nodeIndex);
        }
    }
}

void main()
{
    uint bufferSize = getBufferSize();
    uint octtreeDepth = getOcttreeDepth();
    uint transferBufferSize = getTransferBufferSize();

    uint root = 0;
    uint head = getPNext(0);

    bool reqestRunning = true;
    uint reqestHead = 0;

    // Check for needs Child Flags for Root.
    for (uint childNr = 0; reqestRunning && childNr < 8; childNr++){

        if (getNeedsChildrenFlag(0, childNr)){
            uint childId = getChildId(getNodeId(0), childNr, octtreeDepth - getNodeDepth(0));
            requestBuffer.nodes[reqestHead] = childId;

            reqestHead++;
            reqestRunning = reqestHead < transferBufferSize;
        }
    }

    resetRenderFlag(0);
    resetNeedsChildrenFlag(0);

    uint counter = 0;
    while (counter < bufferSize && head != 0){
        uint next_head = getPNext(head);

        // move node if renderd;
        bool render = getRenderFlag(head);
        if (render) {
            extractNode(head);
            insterNodeAfter(head, root);

            // Check for needs Child Flags.
            for (uint childNr = 0; reqestRunning && childNr < 8; childNr++){

                if (getNeedsChildrenFlag(head, childNr)){

                    


                    uint childId = getChildId(getNodeId(head), childNr, octtreeDepth - getNodeDepth(head));
                    requestBuffer.nodes[reqestHead] = childId;

                    reqestHead++;
                    reqestRunning = reqestHead < transferBufferSize;

                    buildNode(head);
                }
            }

            resetRenderFlag(head);
            resetNeedsChildrenFlag(head);
        }

        head = next_head;
        counter++;
    }

    while (reqestHead < transferBufferSize){
        requestBuffer.nodes[reqestHead] = 0;
        reqestHead++;
    }

    head = getPLast(0);
    counter = 0;
    while (counter < transferBufferSize){
        uint next_head = getPLast(head);

        Node newNode = transferBuffer.nodes[counter];

        if (getNodeId(newNode) == 0) {
            break;
        }

        uint old_parent = getParentIndex(head);

        extractNode(head);
        setNode(head, newNode);
        insterNodeAfter(head, root);

        resetRenderFlag(head);
        resetNeedsChildrenFlag(head);

        buildNode(head);
        buildNode(old_parent);

        head = next_head;
        counter++;
    }
}