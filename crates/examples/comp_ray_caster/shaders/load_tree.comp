#version 450

#extension GL_AMD_gpu_shader_int16: enable
#extension GL_EXT_shader_explicit_arithmetic_types: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;


// Octtree Start
#define Bit_8_MAX 255
#define Bit_16_MAX 65535

struct Node{
    uint16_t children[8];
    uvec4 data;
};

layout(binding = 0) buffer OcttreeBuffer {
    Node octtree[];
} octtreeBuffer;

layout(binding = 1) uniform OcttreeInfo {
    uvec4 data_0;
    uvec4 data_1;
} octtreeInfo;


uint getChildIndex(Node node, uint childIndex){
    return node.children[childIndex];
}
uint getChildIndexbyIndex(uint index, uint childIndex){
    return octtreeBuffer.octtree[index].children[childIndex];
}
void setChildIndex(uint index, uint childIndex, uint newIndex){
    octtreeBuffer.octtree[index].children[childIndex] = uint16_t(newIndex);
}


uint getNodeId(Node node){
    return node.data[0];
}
uint getNodeIdbyIndex(uint index){
    return octtreeBuffer.octtree[index].data[0];
}

uint getNodeMaterial(Node node){
    return node.data[2];
}
uint getNodeMaterialbyIndex(uint index){
    return octtreeBuffer.octtree[index].data[2];
}

uint getNodeDepth(Node node){
    return node.data[3] & Bit_8_MAX;
}
uint getNodeDepthIndex(uint index){
    return octtreeBuffer.octtree[index].data[3] & Bit_8_MAX;
}

bool getRenderFlag(Node node){
    return bool(node.data[3] & (1 << 8));
}
void setRenderFlag(uint index){
    octtreeBuffer.octtree[index].data[3] |= (1 << 8);
}
void resetRenderFlag(uint index){
    octtreeBuffer.octtree[index].data[3] &= ~(1 << 8);
}

bool getNeedsChildrenFlag(Node node, uint childNr){
    return bool(node.data[3] & (1 << (16 + childNr)));
}
void setNeedsChildrenFlag(uint index, uint childNr){
    octtreeBuffer.octtree[index].data[3] |= (1 << (16 + childNr));
}
void resetNeedsChildrenFlag(uint index){
    octtreeBuffer.octtree[index].data[3] &= ~(Bit_16_MAX << 16);
}

Node getNode(uint index){
    return octtreeBuffer.octtree[index];
}
void setNode(uint index, Node node){
    octtreeBuffer.octtree[index] = node;
}

uint getTreeSize(){
    return octtreeInfo.data_0[0];
}
uint getBufferSize(){
    return octtreeInfo.data_0[1];
}
uint getTransferBufferSize(){
    return octtreeInfo.data_0[2];
}
uint getOcttreeDepth(){
    return octtreeInfo.data_0[3];
}
uint getWorkerSizeBuffer(){
    return octtreeInfo.data_1[0];
}
uint getWorkerSizeTransfer(){
    return octtreeInfo.data_1[1];
}
uint getTransferOffset(){
    return octtreeInfo.data_1[2];
}
// Octtree End


layout(binding = 2) buffer TransferBuffer {
    Node nodes[];
} transferBuffer;

layout(binding = 3) buffer RequestBuffer {
    uint nodes[];
} requestBuffer;


uint getChildId(uint nodeId, uint childNr, uint depth){
    int childSize = int((1 - pow(8, depth)) / -7);
    return uint(nodeId + childSize * childNr + 1);
}


float rand(vec2 co){
   return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);
}

uint randRange(uint from, uint to, uint x, uint y){
    float randFloat = rand(vec2(x, y));

    return from + uint(float(to - from) * randFloat);
}

void main()
{
    uint bufferSize = getBufferSize();
    uint transferBufferSize = getTransferBufferSize();
    uint octtreeDepth = getOcttreeDepth();
    uint workerSizeBuffer = getWorkerSizeBuffer();
    uint workerSizeTransfer = getWorkerSizeTransfer();
    uint transferOffset = + getTransferOffset();

    uint startIndex = gl_GlobalInvocationID.x * workerSizeBuffer;

    uint transferHead = gl_GlobalInvocationID.x * workerSizeTransfer;
    uint transferEnd = transferHead + workerSizeTransfer;

    uint reqestHead = transferHead;
    uint reqestEnd = transferEnd;

    bool reqestRunning = true;
    bool transferRunning = true;

    for (int i = 0; i < workerSizeBuffer; i++){

        uint index = (int(i - transferOffset) % workerSizeBuffer) + startIndex;

        Node node = getNode(index);
        bool renderFlag = getRenderFlag(node);

        if (renderFlag){
            // Check for needs Child Flags.
            for (uint childNr = 0; reqestRunning && childNr < 8; childNr++){

                if (getNeedsChildrenFlag(node, childNr)){
                    uint childId = getChildId(getNodeId(node), childNr, octtreeDepth - getNodeDepth(node));
                    requestBuffer.nodes[reqestHead] = childId;

                    reqestHead++;
                    reqestRunning = reqestHead < reqestEnd;
                }
            }

            resetRenderFlag(index);
            resetNeedsChildrenFlag(index);
        }
        else{
            if (transferRunning){
            Node newNode = transferBuffer.nodes[transferHead];

                if (getNodeId(newNode) != 0){
                setNode(index, newNode);
            }

            transferHead++;
                transferRunning = transferHead < transferEnd;
            }
        }
    }

    while (reqestHead < reqestEnd){
        requestBuffer.nodes[reqestHead] = 0;
        reqestHead++;
    }
}