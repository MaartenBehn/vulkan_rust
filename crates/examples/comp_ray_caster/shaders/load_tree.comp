#version 450

#extension GL_AMD_gpu_shader_int16: enable
#extension GL_EXT_shader_explicit_arithmetic_types: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable
#extension GL_EXT_debug_printf : enable

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;


// Octtree Start
#define Bit_8_MAX 255
#define Bit_16_MAX 65535

struct Node{
    uint16_t children[8];
    uvec4 dynamik_data; // 0: Parent 1: PNext 2: PLast     3:
    uvec4 static_data;  // 0: Id     1:       2: Material  3: Depth
};

layout(std430, binding = 0) buffer OcttreeBuffer {
    Node octtree[];
} octtreeBuffer;

layout(binding = 1) uniform OcttreeInfo {
    uvec4 data_0;
    uvec4 data_1;
} octtreeInfo;

// Node
#define GET_NODE(index) octtreeBuffer.octtree[index]
#define SET_NODE(node, index) octtreeBuffer.octtree[index] = node


// Child Index
#define GET_CHILD_INDEX(node, childNr) node.children[childNr]
#define SET_CHILD_INDEX(node, childNr, childIndex) node.children[childNr] = uint16_t(childIndex)

#define GET_CHILD_INDEX_BY_INDEX(index, childNr) octtreeBuffer.octtree[index].children[childNr]
#define SET_CHILD_INDEX_BY_INDEX(index, childNr, childIndex) octtreeBuffer.octtree[index].children[childNr] = uint16_t(childIndex)

// Parent Index
#define GET_PARENT_INDEX(node) node.dynamik_data[0]
#define SET_PARENT_INDEX(node, parentIndex) node.dynamik_data[0] = parentIndex

#define GET_PARENT_INDEX_BY_INDEX(index) octtreeBuffer.octtree[index].dynamik_data[0]
#define SET_PARENT_INDEX_BY_INDEX(index, parentIndex) octtreeBuffer.octtree[index].dynamik_data[0] = parentIndex

// P Next
#define GET_P_NEXT(node) node.dynamik_data[1]
#define SET_P_NEXT(node, pNext) node.dynamik_data[1] = pNext

#define GET_P_NEXT_BY_INDEX(index) octtreeBuffer.octtree[index].dynamik_data[1]
#define SET_P_NEXT_BY_INDEX(index, pNext) octtreeBuffer.octtree[index].dynamik_data[1] = pNext

// P Last
#define GET_P_LAST(node) node.dynamik_data[2]
#define SET_P_LAST(node, pLast) node.dynamik_data[2] = pLast

#define GET_P_LAST_BY_INDEX(index) octtreeBuffer.octtree[index].dynamik_data[2]
#define SET_P_LAST_BY_INDEX(index, pLast) octtreeBuffer.octtree[index].dynamik_data[2] = pLast

// Flags
#define RESET_FLAGS(index) octtreeBuffer.octtree[index].dynamik_data[3] = 0

// Render Flag
#define GET_RENDER_FLAG(node) bool(node.dynamik_data[3] & 1)
#define SET_RENDER_FLAG(node) node.dynamik_data[3] |= 1
#define RESET_RENDER_FLAG(node) node.dynamik_data[3] &= ~1

#define GET_RENDER_FLAG_BY_INDEX(index) bool(octtreeBuffer.octtree[index].dynamik_data[3] & 1)
#define SET_RENDER_FLAG_BY_INDEX(index) octtreeBuffer.octtree[index].dynamik_data[3] |= 1
#define RESET_RENDER_FLAG_BY_INDEX(index) octtreeBuffer.octtree[index].dynamik_data[3] &= ~1

// Needs Child
#define GET_NEEDS_CHILD(node, childNr) bool(node.dynamik_data[3] & (1 << (16 + childNr)))
#define SET_NEEDS_CHILD(node, childNr) node.dynamik_data[3] |= (1 << (16 + childNr))
#define RESET_NEEDS_CHILDREN(node) node.dynamik_data[3] &= ~(Bit_8_MAX << 16)

#define GET_NEEDS_CHILD_BY_INDEX(index, childNr) bool(octtreeBuffer.octtree[index].dynamik_data[3] & (1 << (16 + childNr)))
#define SET_NEEDS_CHILD_BY_INDEX(index, childNr) octtreeBuffer.octtree[index].dynamik_data[3] |= (1 << (16 + childNr))
#define RESET_NEEDS_CHILDREN_BY_INDEX(index) octtreeBuffer.octtree[index].dynamik_data[3] &= ~(Bit_8_MAX << 16)

// ID
#define GET_NODE_ID(node) node.static_data[0]
#define SET_NODE_ID(node, id) node.static_data[0] = id

#define GET_NODE_ID_BY_INDEX(index) octtreeBuffer.octtree[index].static_data[0]
#define SET_NODE_ID_BY_INDEX(index, id) octtreeBuffer.octtree[index].static_data[0] = id

// Material
#define GET_MATERIAL_ID(node) node.static_data[2]
#define SET_MATERIAL_ID(node, material) node.static_data[2] = material

#define GET_MATERIAL_ID_BY_INDEX(index) octtreeBuffer.octtree[index].static_data[2]
#define SET_MATERIAL_ID_BY_INDEX(index, material) octtreeBuffer.octtree[index].static_data[2] = material

// Depth
#define GET_NODE_DEPTH(node) node.static_data[3]
#define SET_NODE_DEPTH(node, depth) node.static_data[3] = depth

#define GET_NODE_DEPTH_BY_INDEX(index) octtreeBuffer.octtree[index].static_data[3]
#define SET_NODE_DEPTH_BY_INDEX(index, depth) octtreeBuffer.octtree[index].static_data[3] = depth


// Octtree Info
#define TREE_SIZE octtreeInfo.data_0[0]
#define BUFFER_SIZE octtreeInfo.data_0[1]
#define TRANSFER_SIZE octtreeInfo.data_0[2]
#define OCTTREE_DEPTH octtreeInfo.data_0[3]

#define BUILD_OFFSET octtreeInfo.data_1[0]
#define RE_BUILD octtreeInfo.data_1[1]
#define LODER_SIZE octtreeInfo.data_1[2]
#define DEBUG bool(octtreeInfo.data_1[3])
// Octtree End

layout(binding = 2) buffer TransferBuffer {
    uvec4 nodes[];
} transferBuffer;

layout(binding = 3) buffer RequestBuffer {
    uint nodes[];
} requestBuffer;

layout(binding = 4) buffer RequestNoteBuffer {
    uint data[];
} requestNoteBuffer;


// Linked List Operations
void extractNode(uint nodeIndex){
    uint p_last = GET_P_LAST_BY_INDEX(nodeIndex);
    uint p_next = GET_P_NEXT_BY_INDEX(nodeIndex);

    SET_P_NEXT_BY_INDEX(p_last, p_next);
    SET_P_LAST_BY_INDEX(p_next, p_last);
}

void insterNodeAfter(uint nodeIndex, uint afterIndex){
    uint after_p_next = GET_P_NEXT_BY_INDEX(afterIndex);
    
    SET_P_NEXT_BY_INDEX(afterIndex, nodeIndex);
    SET_P_LAST_BY_INDEX(nodeIndex, afterIndex);

    SET_P_NEXT_BY_INDEX(nodeIndex, after_p_next);
    SET_P_LAST_BY_INDEX(after_p_next, nodeIndex);
}

uint getChildId(uint nodeId, uint childNr, uint depth){
    int childSize = int((1 - pow(8, depth)) / -7);
    return uint(nodeId + childSize * childNr + 1);
}

void main()
{
    uint bufferSize = BUFFER_SIZE;
    uint octtreeDepth = OCTTREE_DEPTH;
    uint transferBufferSize = TRANSFER_SIZE;
    uint loaderSize = LODER_SIZE;

    uint root = 0;
    uint head = GET_P_LAST_BY_INDEX(0);

    for (uint counter = 0; counter < transferBufferSize; counter++){
        uint next_head = GET_P_LAST_BY_INDEX(head);

        uvec4 new_data = transferBuffer.nodes[counter];
        Node newNode = Node(
            uint16_t[8](uint16_t(0),uint16_t(0),uint16_t(0),uint16_t(0), uint16_t(0),uint16_t(0),uint16_t(0),uint16_t(0)),
            uvec4(0, 0, 0, 0),
            new_data
        );

        if (GET_NODE_ID(newNode) == 0) {
            break;
        }

        uint parent_index = requestNoteBuffer.data[counter * 4];
        uint parent_childNr = requestNoteBuffer.data[(counter * 4) + 1];
        uint check_parent_Id = requestNoteBuffer.data[(counter * 4) + 2];
        uint check_child_Id = requestNoteBuffer.data[(counter * 4) + 3];

        if (GET_NODE_ID(newNode) != check_child_Id || GET_NODE_ID_BY_INDEX(parent_index) != check_parent_Id){
            //debugPrintfEXT("Node transfer skipped!!!");
            continue;
        }

        uint old_parent = GET_PARENT_INDEX_BY_INDEX(head);
        Node old_parent_node = GET_NODE(old_parent);
        for (uint i = 0; i < 8; i++){
            if (GET_CHILD_INDEX(old_parent_node, i) == head){
                SET_CHILD_INDEX_BY_INDEX(old_parent, i, 0);
            }
        }

        extractNode(head);
        
        SET_NODE(newNode, head);
        SET_PARENT_INDEX_BY_INDEX(head, parent_index);

        insterNodeAfter(head, root);

        SET_CHILD_INDEX_BY_INDEX(parent_index, parent_childNr, head);

        head = next_head;
    }

    head = requestNoteBuffer.data[transferBufferSize * 4];

    bool reqestRunning = true;
    uint reqestHead = 0;
    uint renderedCounter = requestBuffer.nodes[transferBufferSize];
    uint needsChilrenCounter = requestBuffer.nodes[transferBufferSize + 1];

    for (uint counter = 0; reqestRunning && counter < loaderSize; counter++){
        uint next_head = GET_P_NEXT_BY_INDEX(head);

        // move node if renderd;
        bool render = GET_RENDER_FLAG_BY_INDEX(head);
        if (render) {
            renderedCounter++;

            if (head != root){
                extractNode(head);
                insterNodeAfter(head, root);
            }

            // Check for needs Child Flags.
            for (uint childNr = 0; reqestRunning && childNr < 8; childNr++){
                if (GET_NEEDS_CHILD_BY_INDEX(head, childNr)){
                    needsChilrenCounter++;


                    uint childId = getChildId(GET_NODE_ID_BY_INDEX(head), childNr, octtreeDepth - GET_NODE_DEPTH_BY_INDEX(head));

                    requestBuffer.nodes[reqestHead] = childId;
                    requestNoteBuffer.data[reqestHead * 4] = head;
                    requestNoteBuffer.data[(reqestHead * 4) + 1] = childNr;
                    requestNoteBuffer.data[(reqestHead * 4) + 2] = GET_NODE_ID_BY_INDEX(head);
                    requestNoteBuffer.data[(reqestHead * 4) + 3] = childId;

                    reqestHead++;
                    reqestRunning = reqestHead < transferBufferSize;
                }
            }
        }

        RESET_RENDER_FLAG_BY_INDEX(head);
        RESET_NEEDS_CHILDREN_BY_INDEX(head);

        head = next_head;        
        
        if (head == 0){
            renderedCounter = 0;
            needsChilrenCounter = 0;
        }
    }

    requestNoteBuffer.data[transferBufferSize * 4] = head;

    while (reqestHead < transferBufferSize){
        requestBuffer.nodes[reqestHead] = 0;

        requestNoteBuffer.data[reqestHead * 4] = bufferSize;
        requestNoteBuffer.data[(reqestHead * 4) + 1] = bufferSize;
        requestNoteBuffer.data[(reqestHead * 4) + 2] = bufferSize;
        requestNoteBuffer.data[(reqestHead * 4) + 3] = bufferSize;
        reqestHead++;
    }

    if (DEBUG) {
        requestBuffer.nodes[transferBufferSize] = renderedCounter;
        requestBuffer.nodes[transferBufferSize + 1] = needsChilrenCounter;
    }
}