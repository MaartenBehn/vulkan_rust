#version 450

#extension GL_AMD_gpu_shader_int16: enable
#extension GL_EXT_shader_explicit_arithmetic_types: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;


// Octtree Start
#define Bit_8_MAX 255
#define Bit_16_MAX 65535

struct Node{
    uint16_t children[8];
    uvec4 data;
};

layout(binding = 0) buffer OcttreeBuffer {
    Node octtree[];
} octtreeBuffer;

layout(binding = 1) uniform OcttreeInfo {
    uvec4 data_0; // 0 is BufferSize, 1 is Buffer Depth, 2 check Index
} octtreeInfo;


uint getChildIndex(Node node, uint childIndex){
    return node.children[childIndex];
}
void setChildIndex(uint index, uint childIndex, uint newIndex){
    octtreeBuffer.octtree[index].children[childIndex] = uint16_t(newIndex);
}

vec3 getNodeColor(Node node){
    uint rg = node.data[0];
    uint ba = node.data[1];

    vec3 color;
    color.r = rg & Bit_16_MAX;
    color.g = rg >> 16;
    color.b = ba & Bit_16_MAX;

    return color / Bit_16_MAX;
}

uint getNodeId(Node node){
    return node.data[2];
}
uint getNodeIdIndex(uint index){
    return octtreeBuffer.octtree[index].data[2];
}

uint getNodeDepth(Node node){
    return node.data[3] & Bit_8_MAX;
}
uint getNodeDepthIndex(uint index){
    return octtreeBuffer.octtree[index].data[3] & Bit_8_MAX;
}

bool getRenderFlag(Node node){
    return bool(node.data[3] & (1 << 8));
}
void setRenderFlag(uint index){
    octtreeBuffer.octtree[index].data[3] |= (1 << 8);
}
void resetRenderFlag(uint index){
    octtreeBuffer.octtree[index].data[3] &= ~(1 << 8);
}

bool getNeedsChildrenFlag(Node node){
    return bool(node.data[3] & (1 << 9));
}
void setNeedsChildrenFlag(uint index){
    octtreeBuffer.octtree[index].data[3] |= (1 << 9);
}
void resetNeedsChildrenFlag(uint index){
    octtreeBuffer.octtree[index].data[3] &= ~(1 << 9);
}


Node getNode(uint index){
    return octtreeBuffer.octtree[index];
}
void setNode(uint index, Node node){
    octtreeBuffer.octtree[index] = node;
}

uint getTreeSize(){
    return octtreeInfo.data_0[0];
}
uint getBufferSize(){
    return octtreeInfo.data_0[1];
}
uint getTransferBufferSize(){
    return octtreeInfo.data_0[2];
}
uint getOcttreeDepth(){
    return octtreeInfo.data_0[3];
}
// Octtree End


layout(binding = 2) buffer TransferBuffer {
    Node nodes[];
} transferBuffer;

layout(binding = 3) buffer RequestBuffer {
    uint nodes[];
} requestBuffer;


uint getChildId(uint nodeId, uint childNr, uint depth){
    int childSize = int((1 - pow(8, depth)) / -7);
    return uint(nodeId + childSize * childNr + 1);
}

void pushNode(Node node, uint nodeIndex){

    for (uint i = nodeIndex - 1; i > 0; i--){
        Node moveNode = getNode(i);
        setNode(i + 1, moveNode);
    }

    setNode(1, node);
}

void main()
{
    uint bufferSize = getBufferSize();
    uint transferBufferSize = getTransferBufferSize();
    uint octtreeDepth = getOcttreeDepth();

    uint reqestHead = 0;
    bool startPushing = false;
    for (int i = 0; i < bufferSize; i++){

        Node node = getNode(i);

        // Check for needs Child Flags.
        if (getNeedsChildrenFlag(node) && reqestHead < transferBufferSize){

            for (uint childNr = 0; childNr < 8; childNr++){
                uint childId = getChildId(getNodeId(node), childNr, octtreeDepth - getNodeDepth(node));
                requestBuffer.nodes[reqestHead] = childId;
                reqestHead++;
            }
        }

        if (!startPushing && !getRenderFlag(node)){
            startPushing = true;
        }
        else if (startPushing && getRenderFlag(node)){
            pushNode(node, i);
        }
    }

    while (reqestHead < transferBufferSize){
        requestBuffer.nodes[reqestHead] = 0;
        reqestHead++;
    }

    uint transferHead = bufferSize - 1;
    for (uint i = 0; i < transferBufferSize; i++){
        Node newNode = transferBuffer.nodes[i];

        if (getNodeId(newNode) == 0){
            break;
        }

        pushNode(newNode, bufferSize - 1);
    }
}