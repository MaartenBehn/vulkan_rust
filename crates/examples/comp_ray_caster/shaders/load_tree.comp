#version 450

#extension GL_AMD_gpu_shader_int16: enable
#extension GL_EXT_shader_explicit_arithmetic_types: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable
#extension GL_EXT_debug_printf : enable

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;


// Octtree Start
#define Bit_8_MAX 255
#define Bit_16_MAX 65535

struct Node{
    uint16_t children[8];
    uvec4 dynamik_data;
    uvec4 static_data;
};

layout(std430, binding = 0) buffer OcttreeBuffer {
    Node octtree[];
} octtreeBuffer;

layout(binding = 1) uniform OcttreeInfo {
    uvec4 data_0;
    uvec4 data_1;
} octtreeInfo;

// Dynamik Data
uint getChildIndex(Node node, uint childIndex){
    return node.children[childIndex];
}
uint getChildIndex(uint index, uint childIndex){
    return octtreeBuffer.octtree[index].children[childIndex];
}
void setChildIndex(uint index, uint childIndex, uint newIndex){
    octtreeBuffer.octtree[index].children[childIndex] = uint16_t(newIndex);
}

uint getParentIndex(Node node){
    return node.dynamik_data[0];
}
uint getParentIndex(uint index){
    return octtreeBuffer.octtree[index].dynamik_data[0];
}
uint setParentIndex(uint index, uint parentIndex){
    return octtreeBuffer.octtree[index].dynamik_data[0] = parentIndex;
}

uint getPNext(Node node){
    return node.dynamik_data[1];
}
uint getPNext(uint index){
    return octtreeBuffer.octtree[index].dynamik_data[1];
}
void setPNext(uint index, uint pNext){
    octtreeBuffer.octtree[index].dynamik_data[1] = pNext;
}

uint getPLast(Node node){
    return node.dynamik_data[2];
}
uint getPLast(uint index){
    return octtreeBuffer.octtree[index].dynamik_data[2];
}
void setPLast(uint index, uint pLast){
    octtreeBuffer.octtree[index].dynamik_data[2] = pLast;
}

bool getRenderFlag(Node node){
    return bool(node.dynamik_data[3] & 1);
}
bool getRenderFlag(uint index){
    return bool(octtreeBuffer.octtree[index].dynamik_data[3] & 1);
}
void setRenderFlag(uint index){
    octtreeBuffer.octtree[index].dynamik_data[3] |= 1;
}
void resetRenderFlag(uint index){
    octtreeBuffer.octtree[index].dynamik_data[3] &= ~1;
}

bool getNeedsChildrenFlag(Node node, uint childNr){
    return bool(node.dynamik_data[3] & (1 << (16 + childNr)));
}
bool getNeedsChildrenFlag(uint index, uint childNr){
    return bool(octtreeBuffer.octtree[index].dynamik_data[3] & (1 << (16 + childNr)));
}
void setNeedsChildrenFlag(uint index, uint childNr){
    octtreeBuffer.octtree[index].dynamik_data[3] |= (1 << (16 + childNr));
}
void resetNeedsChildrenFlag(uint index){
    octtreeBuffer.octtree[index].dynamik_data[3] &= ~(Bit_16_MAX << 16);
}

Node getNode(uint index){
    return octtreeBuffer.octtree[index];
}
void setNode(Node node, uint index){
    octtreeBuffer.octtree[index] = node;
}

// Static Data
uint getNodeId(Node node){
    return node.static_data[0];
}
uint getNodeId(uint index){
    return octtreeBuffer.octtree[index].static_data[0];
}
void setNodeId(Node node, uint id){
    node.static_data[0] = id;
}

uint getNodeMaterial(Node node){
    return node.static_data[2];
}
uint getNodeMaterial(uint index){
    return octtreeBuffer.octtree[index].static_data[2];
}
void setNodeMaterial(Node node, uint index){
    node.static_data[2] = index;
}

uint getNodeDepth(Node node){
    return node.static_data[3];
}
uint getNodeDepth(uint index){
    return octtreeBuffer.octtree[index].static_data[3];
}
void setNodeDepth(Node node, uint depth){
    node.static_data[3] = depth;
}

// Octtree Info
uint getTreeSize(){
    return octtreeInfo.data_0[0];
}
uint getBufferSize(){
    return octtreeInfo.data_0[1];
}
uint getTransferBufferSize(){
    return octtreeInfo.data_0[2];
}
uint getOcttreeDepth(){
    return octtreeInfo.data_0[3];
}
uint getBuildOffset(){
    return octtreeInfo.data_1[0];
}
uint getReBuild(){
    return octtreeInfo.data_1[1];
}
// Octtree End

layout(binding = 2) buffer TransferBuffer {
    uvec4 nodes[];
} transferBuffer;

layout(binding = 3) buffer RequestBuffer {
    uint nodes[];
} requestBuffer;

layout(binding = 4) buffer RequestNoteBuffer {
    uint data[];
} requestNoteBuffer;


// Linked List Operations
void extractNode(uint nodeIndex){
    uint p_last = getPLast(nodeIndex);
    uint p_next = getPNext(nodeIndex);

    setPNext(p_last, p_next);
    setPLast(p_next, p_last);
}

void insterNodeAfter(uint nodeIndex, uint afterIndex){
    uint after_p_next = getPNext(afterIndex);
    
    setPNext(afterIndex, nodeIndex);
    setPLast(nodeIndex, afterIndex);

    setPNext(nodeIndex, after_p_next);
    setPLast(after_p_next, nodeIndex);
}

uint getChildId(uint nodeId, uint childNr, uint depth){
    int childSize = int((1 - pow(8, depth)) / -7);
    return uint(nodeId + childSize * childNr + 1);
}

void main()
{
    uint bufferSize = getBufferSize();
    uint octtreeDepth = getOcttreeDepth();
    uint transferBufferSize = getTransferBufferSize();

    uint root = 0;
    uint head = getPLast(0);

    for (uint counter = 0; counter < transferBufferSize; counter++){
        uint next_head = getPLast(head);

        uvec4 new_data = transferBuffer.nodes[counter];
        Node newNode = Node(
            uint16_t[8](uint16_t(0),uint16_t(0),uint16_t(0),uint16_t(0), uint16_t(0),uint16_t(0),uint16_t(0),uint16_t(0)),
            uvec4(0, 0, 0, 0),
            new_data
        );

        if (getNodeId(newNode) == 0) {
            break;
        }

        uint parent_index = requestNoteBuffer.data[counter * 4];
        uint parent_childNr = requestNoteBuffer.data[(counter * 4) + 1];
        uint check_parent_Id = requestNoteBuffer.data[(counter * 4) + 2];
        uint check_child_Id = requestNoteBuffer.data[(counter * 4) + 3];

        if (getNodeId(newNode) != check_child_Id || getNodeId(parent_index) != check_parent_Id){
            debugPrintfEXT("Node transfer skipped!!!");
            continue;
        }

        uint old_parent = getParentIndex(head);
        Node old_parent_node = getNode(old_parent);
        for (uint i = 0; i < 8; i++){
            if (getChildIndex(old_parent_node, i) == head){
                setChildIndex(old_parent, i, 0);
            }
        }

        extractNode(head);
        
        setNode(newNode, head);
        setParentIndex(head, parent_index);

        insterNodeAfter(head, root);

        setChildIndex(parent_index, parent_childNr, head);

        head = next_head;
    }

    head = 0;

    bool reqestRunning = true;
    uint reqestHead = 0;
    uint renderedCounter = 0;
    uint needsChilrenCounter = 0;

    for (uint counter = 0; counter < bufferSize; counter++){
        uint next_head = getPNext(head);

        // move node if renderd;
        bool render = getRenderFlag(head);
        if (render) {
            renderedCounter++;

            if (head != root){
                extractNode(head);
                insterNodeAfter(head, root);
            }

            // Check for needs Child Flags.
            for (uint childNr = 0; reqestRunning && childNr < 8; childNr++){
                if (getNeedsChildrenFlag(head, childNr)){
                    needsChilrenCounter++;


                    uint childId = getChildId(getNodeId(head), childNr, octtreeDepth - getNodeDepth(head));

                    requestBuffer.nodes[reqestHead] = childId;
                    requestNoteBuffer.data[reqestHead * 4] = head;
                    requestNoteBuffer.data[(reqestHead * 4) + 1] = childNr;
                    requestNoteBuffer.data[(reqestHead * 4) + 2] = getNodeId(head);
                    requestNoteBuffer.data[(reqestHead * 4) + 3] = childId;

                    reqestHead++;
                    reqestRunning = reqestHead < transferBufferSize;
                }
            }
        }

        resetRenderFlag(head);
        resetNeedsChildrenFlag(head);

        head = next_head;
        if (head == root){
            break;
        }
    }

    while (reqestHead < transferBufferSize){
        requestBuffer.nodes[reqestHead] = 0;

        requestNoteBuffer.data[reqestHead * 4] = bufferSize;
        requestNoteBuffer.data[(reqestHead * 4) + 1] = bufferSize;
        requestNoteBuffer.data[(reqestHead * 4) + 2] = bufferSize;
        requestNoteBuffer.data[(reqestHead * 4) + 3] = bufferSize;
        reqestHead++;
    }

    requestBuffer.nodes[transferBufferSize] = renderedCounter;
    requestBuffer.nodes[transferBufferSize + 1] = needsChilrenCounter;
}