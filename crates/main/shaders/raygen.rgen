#version 460
#extension GL_EXT_ray_tracing : enable

// ------ Bindings ------ 
layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 1, rgba8) uniform image2D image;
layout(binding = 2, set = 0) uniform SceneData {
	mat4 invertedView;
	mat4 invertedProj;
	vec4 lightDirection;
	vec4 lightColor;
	uint maxDepth;
	uint rays_per_pixel;
	uint render_mode;
} scene;

struct RayData{
	vec3 origin;
	vec3 direction;
	uint missIndex;
	float tmin;
	float tmax;
};

// ------ HitInfo ------ 
layout(location = 0) rayPayloadEXT HitInfo {
	bool missed;
	vec4 hitValue;
	vec3 hitOrigin;
	vec3 hitNormal;
} hitInfo;

RayData get_ray_data(){
	RayData ray_data; 

	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
	const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
	const vec2 d = (inUV * 2.0 - 1.0);

	ray_data.origin = vec3(scene.invertedView * vec4(0, 0, 0, 1));
	vec3 target = normalize(vec3(scene.invertedProj * vec4(d.x, d.y, 1, 1)));
	ray_data.direction = vec3(scene.invertedView * vec4(target, 0));

	ray_data.missIndex = 0;
	ray_data.tmin = 0.001;
	ray_data.tmax = 100.0;

	return ray_data;
}

vec3 render_debug_reflections(RayData ray_data){
	traceRayEXT(
		topLevelAS, 
		gl_RayFlagsOpaqueEXT, 
		0xff, 
		0, 0, 
		ray_data.missIndex, 
		ray_data.origin, 
		ray_data.tmin, 
		ray_data.direction, 
		ray_data.tmax, 
		0
	);

	const vec3 color = vec3(1.0, 0.0, 0.0) * vec3(hitInfo.hitValue[3] >= 1.0 && !hitInfo.missed) + 
		vec3(0.0, 1.0, 0.0) * vec3(!(hitInfo.hitValue[3] >= 1.0) && !hitInfo.missed);

	return color;
}

vec3 render_debug_color(RayData ray_data){
	traceRayEXT(
		topLevelAS, 
		gl_RayFlagsOpaqueEXT, 
		0xff, 
		0, 0, 
		ray_data.missIndex, 
		ray_data.origin, 
		ray_data.tmin, 
		ray_data.direction, 
		ray_data.tmax, 
		0
	);

	return vec3(hitInfo.hitValue[0], hitInfo.hitValue[1], hitInfo.hitValue[2]);
}

vec3 render_main(RayData ray_data){
	hitInfo.hitValue = vec4(0.0);

	vec3 color = vec3(0.0);
	float absorbMul = 1.0;
	for(uint i = 0; i < scene.maxDepth; i++) {
		traceRayEXT(
			topLevelAS, 
			gl_RayFlagsOpaqueEXT, 
			0xff, 
			0, 0, 
			ray_data.missIndex, 
			ray_data.origin, 
			ray_data.tmin, 
			ray_data.direction, 
			ray_data.tmax, 
			0
		);

		color += vec3(hitInfo.hitValue[0], hitInfo.hitValue[1], hitInfo.hitValue[2]) * vec3(hitInfo.hitValue[3]) * vec3(absorbMul);
		absorbMul *= 0.8;

		if (hitInfo.missed || hitInfo.hitValue[3] >= 1.0) {
			break;
		}

		ray_data.origin = hitInfo.hitOrigin;
		ray_data.direction = reflect(ray_data.direction, hitInfo.hitNormal);
	}

	return color;
}

void main() {
	RayData ray_data = get_ray_data();

	vec3 color = vec3(0.0);
	if (scene.render_mode == 0){
		color = render_debug_reflections(ray_data);
	}
	else if (scene.render_mode == 1){
		color = render_debug_color(ray_data);
	}
	else if (scene.render_mode == 2){
		color = render_main(ray_data);
	}

	imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(color, 1.0));
}
